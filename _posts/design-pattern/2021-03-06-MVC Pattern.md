---
layout: post
title: "[디자인패턴] MVC 패턴(MVC Pattern)"
categories: [Design Pattern]
---

관심사의 분리, MVC 패턴

# MVC 패턴
어플리케이션을 사용자 인터페이스(사용자가 보는 페이지), 비즈니스 로직, 그리고 이 2가지를 중간에서 제어하는 컨트롤러로 나누어 작성하는 디자인패턴입니다.

## 왜 MVC패턴을 사용해야 할까?

모델, 뷰, 칸트롤러로 역할을 나눔으로써 각각 맡은 바에만 집중할 수 있으며, 서로간의 영향없이 쉽게 고칠 수 있는 어플리케이션을 만들 수 있습니다. 유지보수성, 애플리케이션의 확장성, 그리고 유연성이 증가하고, 중복코딩이라는 문제점 또한 사라지게 됩니다.

- 유연성: 클라이언트의 새로운 요구사항을 최소한의 비용으로 만족시키는 것

## 모델, Model

어플리케이션의 데이터와 데이터 가공을 책임지는 컴포넌트를 말합니다.

모델은 다음과 같은 규칙을 가지고 있다.

### 1. 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 한다.

즉, 화면안의 네모박스에 글자가 표현된다면, 네모박스의 화면 위치 정보, 네모박스의 크기정보, 글자내용, 글자의 위치, 글자의 포맷 정보 등을 가지고 있어야 한다는 것입니다.

### 2. 뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야 한다.

데이터 변경이 일어났을 때 모델에서 화면 UI를 직접 조정해서 수정할 수 있도록 뷰를 참조하는 내부 속성값을 가지면 안 된다는 말입니다.

## 뷰, View

사용자가 보는 화면에 입출력 과정 및 결과를 보여주기 위한 역할을 합니다. 입출력의 순서나 데이터 양식은 컨트롤러에 종속되어 결정되고, 도메인 모델의 상태를 변환하거나, 받아서 렌더링하는 역할을 합니다.

뷰에서는 다음과 같은 규칙들이 있습니다.

### 1. 모델이 가지고 있는 정보를 따로 저장해서는 안된다.

화면에 글자를 표시 하기 위해, 모델이 가지고 있는 정보를 전달받게 될텐데, 그 정보를 유지하기 위해서 임의의 뷰 내뷰에 저장하면 안됩니다. 단순히 네모 박스를 그리라는 명령을 받으면, 화면에 표시하기만 하고 그 화면을 그릴 때 필요한 정보들은 저장하지 않아야 합니다.

### 2. 모델이나 컨트롤러와 같이 다른 구성요소들을 몰라야 된다.

모델과 같은 자기 자신의 빼고는 다른 요소는 참조하거나 어떻게 동작하는지 알아서는 안됩니다. 그냥 뷰는 데이터를 받으면 화면에 표시해주는 역할만 가진다고 보면 됩니다.

그렇기 때문에 view에서는 도메인 객체의 상태를 따로 저장하고 관리하는 클래스 변수 혹은 인스턴스 변수가 있을 필요가 없습니다.

## 컨트롤러, Controller

데이터와 사용자인터페이스 요소들을 잇는 다리역할을 합니다.

즉, 사용자가 데이터를 클릭하고, 수정하는 것에 대한 "이벤트"들을 처리하는 부분을 뜻합니다.

도메인 객체들의 조합을 통해 프로그램의 작동 순서나 방식을 제어합니다.

웹 프로그래밍에서는 Controller에서 service layer를 분리하여 domain 로직이 수행되는 곳과 view의 요청을 매핑하는 곳을 독립적으로 관리할 수 있습니다.

컨트롤러 또한 다음과 같은 규칙을 이해해야 합니다.

### 1. 모델이나 뷰에 대해서 알고 있어야 한다.

모델이나 뷰는 서로의 존재를 모르고, 변경을 외부로 알리고, 수신하는 방법만 가지고 있는데 이를 컨트롤러가 중재하기 위해 모델과 그에 관련된 뷰에 대해서 알고 있어야 합니다.

### 2. 모델이나 뷰의 변경을 모니터링 해야 한다.

모델이나 뷰의 변경 통지를 받으면 이를 해석해서 각각의 구성 요소에게 통지를 해야 합니다.

또한, 애플리케이션의 메인 로직은 컨트롤러가 담당하게 됩니다.

웹 프로그래밍에서는 Controller에서 service layer를 분리하여 domain 로직이 수행되는 곳과 view의 요청을 매핑하는 곳을 독립적으로 관리할 수 있다.

### 3. 상태가 변하는 필드를 갖지 말아야 한다.

컨트롤러는 뷰와 모델의 중간다리 역할을 한다. 뷰에서 입력받은 요청을 올바른 모델에게 전달하는 역할을 하는 것이 컨트롤러이다. 따라서 어떠한 상태를 가질 필요가 없다. 그저 올바른 모델에게 전달만 해주면 될 뿐이다.

엄밀히 따져서 Controller가 필드를 가지지 말라는 건 Controller가 도메인 모델처럼 상태가 변하는 필드를 두고서 관리하는 Object로 만들면 안된다는 것이다.

상태를 고려하여 사용해야 한다는 것 자체가 그에 따른 로직이 들어가야 한다는 소리이다. 그러면 이는 단순히 View - Model을 잇는 컨트롤러 역할에 무언가가 추가되는 것이다.

스프링에선 어째서 Controller가 Service or Repository를 필드로 갖고 있는 걸까? 컨테이너로부터 의존성을 주입받으려면 필드로 갖고 있을 수 밖에 없기 때문에? 그렇다면 의존성을 주입받는다면 필드로 갖고 있어도 되는 것일까?

도메인 모델의 상태로서 관리할 필드와 상태가 없는 Service, Repositoty 레이어 필드를 나눌 필요가 있다.

Controller, Service, Repository는 자신의 상태를 관리하는 로직을 가지고 있지 않다. 자신의 layer에 맞는 역할을 수행할 때 참조해야할 존재들만 가지고 있다.

스프링에선 주로 Service layer 필드를 가진다. 하지만 Service도 별도의 상태를 가지고 있진 않다. 스프링의 컨트롤러가 자신의 필드인 Service가 현재 어떤 상태인지 고려하여 사용을 하지 않는다.

또, 컨트롤러가 필드를 갖고 있다면 같은 API, 파라미터로 요청을 해도 요청마다 필드가 변할 수 있기 때문에 멱등성을 유지하지 못할 수 있다.

## Reference

- [MVC 패턴]([https://m.blog.naver.com/jhc9639/220967034588](https://m.blog.naver.com/jhc9639/220967034588))
- [모델-뷰-컨트롤러]([https://ko.wikipedia.org/wiki/모델-뷰-컨트롤러](https://ko.wikipedia.org/wiki/%EB%AA%A8%EB%8D%B8-%EB%B7%B0-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC))
- [MVC 패턴]([https://dinfree.com/lecture/backend/javaweb_3.1.html](https://dinfree.com/lecture/backend/javaweb_3.1.html))
